# caesar_cipher

Программы на python для шифрования и расшифровки текста, а также взлома шифра, сделанные в качестве лабораторной работы по информационной безопасности.

## Описание алгоритмов шифрования-расшифровки

Используется алгоритм шифрования Цезаря с ключевым словом.

В зависимости от введённой пользователем цифры производится либо шифрование текста из файла (путь к которому указывает пользователь), либо его расшифровка. Помимо этого, пользователю также необходимо ввести ключевое слово и число k, используемые для шифрования и расшифровки.

В обоих случаях текст считывается из файла, после чего очищается от любых символов, которые не являются буквами английского алфавита или пробелами. Удаляются в том числе табуляции, переходы на другую строку и другие нечитаемые символы. Если удаляемые символы нельзя удалить так, чтобы два слова, разделяемые ими, не “склеились” в одно, то такие символы заменяются пробелами. Все заглавные буквы преобразуются в строчные.

В таком “обработанном” виде текст подаётся на вход шифрующей или дешифрующей функции.

Шифрующая функция работает следующим образом:

* Ключевое слово преобразуется в список.
* Формируется список, содержащий те буквы алфавита, которых нет в ключевом слове.
* Эти списки объединяются в один: получается список, содержащий все буквы алфавита в порядке, при котором первыми идут буквы ключевого слова, а затем все остальные буквы в том порядке, в каком они расположены в алфавите.
* Получившийся список разделяется на два: в первом – последние k букв, а во втором – все остальные буквы.
* Эти списки снова объединяются в один, таким образом, мы получаем алфавит, в котором буквы переставлены в соответствии с ключевым словом и числом k, как требуется согласно методу шифрования Цезаря.
* Далее, в цикле каждая буква поданного на вход текста сравнивается со всеми буквами алфавита (оригинального).
* Если буква из текста равна букве из алфавита, то буква из списка c переставленными буквами, который был получен ранее, которая стоит на позиции, на которой находится совпавшая буква алфавита, заменяет собой букву из исходного текста. То есть все буквы исходного текста заменяются в соответствии с их позициями в алфавите (на самом деле они не заменяются, вместо этого старый текст остаётся таким же, просто создаётся новый текст, в состоящий из заменённых таким образом букв).
* Получившийся текст возвращается функцией в качестве результата

Дешифрующая функция работает следующим образом:

Первые шаги аналогичны шагам в шифрующей функции:

* Ключевое слово преобразуется в список.
* Формируется список, содержащий те буквы алфавита, которых нет в ключевом слове.
* Эти списки объединяются в один: получается список, содержащий все буквы алфавита в порядке, при котором первыми идут буквы ключевого слова, а затем все остальные буквы в том порядке, в каком они расположены в алфавите.
* Получившийся список разделяется на два: в первом – последние k букв, а во втором – все остальные буквы.
* Эти списки снова объединяются в один, таким образом, мы получаем алфавит, в котором буквы переставлены в соответствии с ключевым словом и числом k, как требуется согласно методу шифрования Цезаря.
* Далее, в цикле каждая буква поданного на вход текста сравнивается со всеми буквами полученного на предыдущем шаге списка с переставленными буквами.
* Если буква из текста равна букве из списка, то буква из алфавита, которая стоит на позиции, на которой находится совпавшая буква списка, заменяет собой букву из исходного текста. То есть все буквы исходного текста заменяются в соответствии с их позициями в списке на буквы алфавита (на самом деле они не заменяются, вместо этого старый текст остаётся таким же, просто создаётся новый текст, в состоящий из заменённых таким образом букв).
* Получившийся текст возвращается функцией в качестве результата

Текст, представляющий из себя результат работы алгоритма, записывается в файл, название которого также вводит пользователь.

## Описание алгоритма взлома

Используется взлом с помощью анализа частот появления символов. Используется информация о частоте появления каждого символа алфавита в тексте, а также словарь. Эти данные считываются из файлов.

Пользователь вводит путь к файлу, из которого надо считать текст для взлома.

Текст считывается, после чего очищается от любых символов, которые не являются буквами английского алфавита или пробелами. Удаляются в том числе табуляции, переходы на другую строку и другие нечитаемые символы. Если удаляемые символы нельзя удалить так, чтобы два слова, разделяемые ими, не “склеились” в одно, то такие символы заменяются пробелами. Все заглавные буквы преобразуются в строчные.

В начале текст отправляется в функцию, которая подсчитывает частоту появления каждой буквы в тексте, и возвращает список букв, отсортированный в соответствии с частотой их появления.

Затем, текст отправляется в функцию, которая формирует предварительный текст, созданный только на основе сопоставления частот появления символов (этот текст записывается в файл preliminary.txt). Она работает следующим образом:

* Каждая буква из зашифрованного текста находится в списке букв, отсортированном в порядке появления этих букв в этом тексте, то есть находится номер в списке для данной буквы (используется цикл)
* К результирующему тексту прибавляется буква, стоящая на соответствующем номере в списке букв, отсортированном по частоте их появления в реальном, незашифрованном тексте.
* Сформированный таким образом в цикле результирующий текст возвращается в качестве результата.

Потом предварительный текст отправляется в функцию, которая формирует уже окончательный вариант текста, на основе анализа словаря.

Эта функция работает следующим образом:

* Текст разделяется на отдельные слова
* Эти слова разделяются на три группы: слова, которые есть в словаре, слова, которых там нет, и слова из одной буквы (последние выделяются в отдельную категорию, потому что в случае, если какая – либо буква перепутана, то всё слово, которое представляет из себя данную букву, может оказаться неправильным, но, тем не менее, может найтись в словаре). Разделение происходит следующим образом:
  * Вычисляется длина слова, и если она меньше двух, слово отправляется, вместе со своей позицией в списке всех слов, в отдельный список.
  * Иначе, если слово найдено или не найдено в словаре, оно отправляется в соответствующий список, вместе со своим номером в списке всех слов.
  * Список слов, для которых не найдено соответствия, сортируется по длине слов (это будет полезно на следующих шагах алгоритма)
  * Три списка возвращаются из функции
* Далее, формируется список букв, про которые можно точно сказать, что они не перепутаны. Это происходит в специальной функции следующим образом:
  * Список слов, для которых найдены соответствия в словаре, проходится в цикле: для каждого слова находится длина.
  * Если длина больше 7, то буквы данного слова добавляются в множество “доверенных” букв.
  * Получившееся множество возвращается из функции
* Далее слова, для которых не найдено соответствия в словаре разделяются на две группы: те, для которых в словаре найдены похожие на них слова и те, для которых похожих слов не найдено. Это происходит в специальной функции следующим образом:
  * Для каждого слова в цикле ищутся слова из словаря, у которых такая же длина.
  * Если такое слово найдено в словаре, подсчитывается количество букв, которые совпадают у слов
  * Если этих букв больше 65%, то найденное слово считается “похожим” и добавляется в список похожих слов, вместе с процентом совпадающих букв.
  * Таким образом формируется список похожих слов, Который затем сортируется по количеству совпадающих букв, чтобы первыми шли наиболее похожие слова.
  * Тако список формируется для каждого слова в цикле.
  * Если этот список оказывается пустым, то считается, что похожих слов не найдено, и слов, для которого велись их поиски, отправляется в специальный список.
  * Если же похожие слова найдены, то и само слово вместе с его номером в списке всех слов, и список похожих на него слов отправляются в другой, специальный список.
  * В итоге оба полученных списка возвращаются из функции в качестве результата.
* Далее формируется список замен слов, а также список заменяемых букв, которые, вероятно, перепутаны. Каждое слово, для которого найдены похожие слова в словаре, сравнивается с этими похожими словами следующим образом: все буквы этих слов сравниваются, и, если буквы разные, то, если они не являются “доверенными”, то сравниваемые слова считаются аналогичными и добавляются с специальный список замен.
* Если же различающиеся буквы оказываются доверенными, то слова считаются ошибочно подобранными, и цикл переходит на другое похожее слово. Таким образом, так как первые слова в списке похожих имеют наибольшее количество одинаковых букв, то шанс правильной замены и быстрой остановки цикла достаточно высок.
* Помимо собственно заменяемых слов, буквы, которые оказываются заменены в этих словах (“недоверенные” буквы), также сохраняются в специальном списке, и в дальнейшем используются.
* Происходит замена слов в списке, содержащем все слова. Слова заменяются на подобранные на предыдущем шаге.
* Для слов, для которых не было найдено похожих в словаре, происходит замена тех букв, которые, вероятно, перепутаны, с помощью списка “не доверенных” букв.
* Затем слова, состоящие из одной буквы, также заменяются на другую букву, если она является недоверенной.
* В конце концов список, со всеми словами текста, теперь содержащий заменённые слова, снова объединяется в единый текст.
* Текст возвращается в качестве результата работы функции, как окончательный результат работы алгоритма.

Результат записывается в файл, указанный пользователем.
